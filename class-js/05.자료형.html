<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자료형</title>
</head>
<body>
    <script>
        // 데이터타입(자료형)은 크게 8가지로 나뉨
        // 초기화와 동시에 할당되는 값이 자료형을 결정함
        let str = '안녕?'; // 문자형 str(String)
        let num = '24'; // 숫자형 num(Number)

            // 문자열 (String)
            // 숫자 (Number)
            // 불린(불값) (Boolean) [true, false]
            // 배열 (Array)
            // 객체 (Object)
            // 함수 (Function)
            // 널 (null)
            // 미정의 (undefined)

        // null vs undefined
            // 널 (null)
                // 변수가 의도적으로 '값이 없음'을 나타내도록 설정된 상태
                // (변수를 명시작으로 비워두고 싶을 때 사용하는 값)
                // (프로그래머가 변수에 의도적으로 '값이 없음'을 할당할 때 자주 사용)
            // 미정의 (undefined)
                // 변수가 선언되었지만, 아직 값이 할당되지 않은 상태
                // (변수 선언 후에 초기화 하지 않으면 기본적으로 undefined 값이 할당됨)
                // (의도적으로 undefined를 할당하는 경우는 거의 없음)
            // 느슨한 비교: == (같다) / 엄격한 비교: === (데이터 타입(자료형)까지 같다)
                // 느슨한 비교에서는 undefined와 null이 서로 같다고 평가해버림
                // 엄격한 비교에서는 서로 타입이 다르기 때문에 같지 않다고 평가함

        // 원시형:
        // 변경할 수 없는 값, 한 번 생성되면 변경 불가능
        // 새로운 값을 할당하면 기존값이 아닌 새로운 값이 메모리에 저장됨
        // 변수에 직접 저장됨 / 값으로 비교됨 / 간단한 값, 숫자, 문자 등...
            // 01. 문자열 (string)
                const string1 = "World!"; // 기호(")를 사용하여 데이터를 만들었음 
                const string2 = `Hello ${string1}`; // 기호(`)를 사용하여 데이터를 만들었음
                console.log(string2);
                // 기호를 사용하여 데이터를 만드는 방식을 리터럴이라고 함
                // ``(백틱) > 템플릿 리터럴
            // 02. 숫자 (Number)
                const number = -123; // 양수, 음수를 모두 취급한다
                const pi = 3.14; // 앞에 숫자가 0일 때는 .14 생략가능
                console.log(number + 1);
                // 초기값으로 데이터 타입을 판단
                // 변수(사칙연산+-*/)숫자 = 가능하다
                console.log(number + undefined); // NaN == Not a Number
                // NaN은 데이터의 타입은 숫자인데 숫자로 표기할 수 없는 값을 뜻함

                // 부동소수점 오류: 소수점 계산을 마냥 믿으면 안됨
                    // 흔히 우리가 사용하는 숫자는 10진수이나 컴퓨터는 2진수임
                    // 10진수를 2진수로 변환하여 계산, 다시 10진수로 변환하여 보여줌
                    // 그 과정에서 간혹 무한 소수라는 개념이 발생하게 되고,
                    // 그걸 유한하게 표현하려고 조금 세부적인 값의 초과 또는 손실을 일으킴
                    // 그 결과, 덧셈과 같은 소수점 연산은 오류가 발생할 수 있음
                    // (근사치로 표현됨 > 의도치 않은 연산 오류 발생)
                    const a = 0.1; // 0.000110011001100110011001100110011...
                    const b = 0.2; // 0.001100110011001100110011001100...
                    console.log(a + b); // 0.30000000000000004 (?)
                // 번외편) 원하는 소수점까지 잘라내기
                    console.log((a + b).toFixed(1));
                    // 소수점 한자리까지 잘라라 > 단, 문자열이 되어버림
                    console.log(Number(a + b).toFixed(1));
                    // 소수점 한자리까지 자르지만, 이번 연산시 자료형을 숫자로 변환함
                    // 다음 호출시, 계속 숫자형이냐? == No.
    </script>
</body>
</html>